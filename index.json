[
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/basics/",
	"title": "Basic Rules",
	"tags": [],
	"description": "",
	"content": "Specification format The syntax used to define the content of a HIM taxonomy is based on YAML and must comply to the YAML specification.\nA HIM taxonomy may contain subtrees that are identical copies of each other, for example descriptions of doors in a vehicle. In order not to have to repeat the content of the subtree multiple times, the subtree can be defined in a separate file, which can then be included into the main tree by the directive\n#include \u0026lt;filename\u0026gt; [prefix] The optional [prefix] specifies a branch name to be prepended to all node names in the included file. The include directive may be used in files that are themselves included. Please note that, from a YAML perspective, the include directive is just another comment.\nA tool is neeed to generate the expanded version of the tree that contains instances of the included subtree, such as the tools developed by the VSS community - COVESA/VSS-Tools.\nThe files defining a HIM taxonomy may have the file extension \u0026lsquo;.him\u0026rsquo;, but the project defining the domain taxonomy may define and use a file extension of their own choice. The format of the files may be transformed from YAML to another format like JSON, in which case it may use a file extension of that format. This also pplies to the file extension of the HIM configuration file.\nHIM is in itself case sensitive. This means that keywords, signal names, types and values normally shall be given with the case specified. It is however recommended not to take advantage of this and reuse the same name with different case, as some implementations may treat VSS identifiers as case insensitive.\nMandatory metadata It is mandatory for all HIM nodes to contain the following metadata:\nName Type Description Some HIM node types also require the following metadata:\nDatatype Default Node name A HIM node shall have the syntax of a YAML mapping block with the key name of the mapping block representing the node name as shown below.\nNodeName: type: x description: abc A node name is recommeded to be unique with the scope of the tree it is used in. The name shall follow the Naming Conventions\nThe qualified node name, which must be unique within the scope of the tree, are defined left-to-right of the concatenation of the node names, starting from the root node of the tree and traversing the tree nodes to the node in focus, with a period (.) as delimiter between node names. An example of a qualified node name, which is called a path, is\na.b.c where a is the name of the root node, b is a child of a, and the node in focus is c, a child of b.\nNode types The node types described here are used by more than one information type, while the node types specifi to a single information type are found in respective parts of this document.\nBranch Struct Property Struct node type The \u0026lsquo;struct\u0026rsquo; node type is used to define a structure data type that groups a number of fields. An example is shown below.\nNodeName: type: struct description: This is a struct node containing its mandatory metadata. This node type must have at least one child of node type property, and must not have children of any other node type.\nProperty Node Type The \u0026lsquo;property\u0026rsquo; node type is used to define the fields of a struct. An example is shown below.\nNodeName: type: property datatype: \u0026#34;any supported datatype, including a reference to a struct definition\u0026#34; description: This is a property node containing its mandatory metadata. The \u0026lsquo;datatype\u0026rsquo; metadata is mandatory for a property node. It may also have optional metadata such as unit, min, max, and allowed.\nA property node can only have a struct node as its parent, and must not have any children.\nDescription Describes the meaning and content of the node. Recommended to start with a capital letter and end with a dot (.).\nOptional Metadata Different information types may then specify further optional metadata that may be used by their supported node types:\nUnit Min Max Allowed Comment Instances Aggregate Deprecation For more information on which information/node types this metadata can be used, please see the rule set documentation for these.\nFor oversight a few general rules are shown here:\nThe entries 1 through 4 cannot be used in branch or service node types. The entries 6 and 7 can only be used in branch type nodes. Datatype See the Datatypes chapter\nUnit See the Units chapter\nMin/Max/Allowed See the Value restrictions chapter\nComment A comment can be used to provide additional informal information on a branch. This could include background information on the rationale for the branch, references to related branches, standards and similar. Recommended to start with a capital letter and end with a dot (.).\nInstances See the Instances chapter. The instances metadata is only allowed in branch type nodes.\nAggregate Defines whether or not this branch is an aggregate. If not defined, this defaults to false. An aggregate is a collection of data nodes that make sense to handle together in a system. A typical example could be GNSS location, where latitude and longitude make sense to read and write together. This is supposed to be deployment specific, and for that reason it is recommendedd not to be defined in a standard HIM tree, but rather be added in a deployment preparation of he tree. For branches that both have instances defined and aggregate: true, then aggregate refers to the signals for individual instances, i.e. signals for different instances can be handled separately. The aggregate metadata is only allowed in branch type nodes.\nDeprecation During the development of a taxonomy nodes might be moved or deleted. Giving users of the taxonomy a chance to adopt to the changes, the original nodes are marked as deprecated with the following rules.\nNodes, which are moved in the tree or are intended to be removed from the specification are marked with the deprecation keyword. The string following the deprecation keyword shall start with the version, when the node was deprecated starting with V (e.g. V2.1) followed by the reason for deprecation. If the node was moved, it shall be indicated by moved to followed by the new node name in dot notation as deprecation reason. This keyword shall be used only if the meta-data of the moved node hasn\u0026rsquo;t changed. If the node is intended to be removed from the specification or the meta data changed, it shall be indicated by removed and optionally the reason for the removal as deprecation reason. Nodes which are deprecated will be removed from the specification, either in the second minor update or, if earlier, the next major update. Example Vehicle.Navigation.CurrentLocation: type: branch description: The current latitude and longitude of the vehicle. deprecation: V2.1 moved to Vehicle.CurrentLocation It is recommended for servers, which are implementing protocols for the vehicle signal specification, to serve old and new nodes during the deprecation period described above.\nStyle Guide The HIM specification must adhere to YAML syntax. To keep different domain taxonomy specifications consistent the following style guide is provided.\nNaming Conventions The recommended naming convention for node elements is to use camel case notation starting with a capital letter. It is recommended to use only A-Z, a-z and 0-9 in node names. For boolean signals it is recommended to start the name with Is.\nExamples:\nSomeBranch.AnotherBranch.MySignalName Naming convention for string literals can be found in the chapter for specifying allowed values.\nLine Length It is recommended that line length in files containing HIM information shall not exceed 120 characters. This is not a strict limit, it is e.g. not recommended to split long URLs present in files over multiple lines.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/resource_data_rule_set/basics/",
	"title": "Data",
	"tags": [],
	"description": "",
	"content": "It is the leaf nodes of a tree that represents and defines the actual data. The definition is expressed by metadata describing the data associated to the node.\nNode Types The node types for representing data entries are:\nSensor Actuator Attribute Please see the respective chapters for more information about these node types.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/service_data_rule_set/basics/",
	"title": "Service Data Model",
	"tags": [],
	"description": "",
	"content": "HIM Service-Data Tree A HIM service data tree contains a taxonomy of microservice declarations. The tree structure is used to create a sets of microservices. Such as set is named Service, or Service Group for larger sets where a set of Service Groups would then form a Service, see the figure below, or the example service data tree.\n*Figure x. HIM service tree structure\nHIM Microservice Data A microservice is in HIM defined by a procedure signature as shown below:\n(output1,..outputN) microServiceName(input1,..inputM)\nwhere\nmicroServiceName is the name of the procedure. input1,..,inputM denotes the input parameters of the procedure, which may be zero or more. output1,..,outputN denotes the output parameters of the procedure, which may be zero or more. HIM only specifies the data defining the above procedure signature, it does not specify details of how a call is made, such as how it is serialized, etc. This is expeted to be defined in an interface specification that uses HIM.\nMicroservice tree structure The general structure of how a microservice is represented in a HIM tree is shown in the figure below.\n*Figure x. HIM microservice tree structure\nThe name of the procedure is the name of the node of the type procedure. The input and output parameters are respectively represented by a node of type iostruct that must have the names \u0026lsquo;Input\u0026rsquo; and \u0026lsquo;Output\u0026rsquo;, respectively. An input/output parameter is represented by a node of type property or symlink. Any Input/Output nodes, and their associated children, are only present if the procedure has at least one parameter of the respective Input/Output.\nMicroservice completion state A microservice may have a significant temporal duration from it is started and until it completes. It may therefore be desireable that the state of the microservice can be observed, as e. g. it may be the case that an ongoing microservice execution does not allow new microservice actuations to be started. If an observable microservice completion state is desired, then the designer of this HIM service domain must create such an output parameter of the microservice. The characteristics of this output parameter can be freely chosen, but below is a proposal that if widely used may help to improve interoperability.\nThe parameter shall be named Completion.\nThe completion state of the HIM microservice is represented by a uint8 datatype value.\nThe allowed values of the microservice state are:\n0-99 : ongoing 100 : ready The rules for how a microservice shall update the state value follows below:\nA fully functioning microservice that is not ongoing shall have the value 100. When a valid microservice request is received the state shall be set to zero (0). The microservice may update the state value as the microservice execution proceeds. When the microservice execution successfully terminates the state value must be set to 100. If there is a need for microservice specific error codes then these should be defined as another output parameter.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/configuration_rule_set/basics/",
	"title": "HIM Configuration Rules",
	"tags": [],
	"description": "",
	"content": "Configuration Overview HIM supports structuring information into different trees instead of bundling it all into one tree. This is likely to lead to that e. g. a server that manages a super domain of somewhat heterogeneous information will have that information represented by multiple trees. HIM enables this \u0026ldquo;forest of trees\u0026rdquo; to be accessed in a homogeneous manner by using the paths of the nodes of the trees to address theinformation contained in the trees. To support the server in managing this forest of trees, a HIM configuration tree provides a representation of the key parameters of this forest. The server may also share this configuration file on request from clients, in order for them to discover the information available by the forest. The HIM model is not restricted to client/server models.\nA file containing this configuration shall have a name starting with \u0026ldquo;HIM_configuration\u0026rdquo;, with an optional suffix that might describe the domain, information type, or version. The file may have the extension \u0026ldquo;.him\u0026rdquo;, which typically would indicate that it is YAML formatted. Any file extension can be used that indicates it has been transformed from its YAML source format to a different format like \u0026ldquo;.json\u0026rdquo;.\nThe configuration tree root node shall have a name starting with \u0026ldquo;HIM_config\u0026rdquo;, which may be followed by additional information such as a descriptive domain name, version, etc.\nA server may share the information of this file with a client that wants to discover what information the server manages.\nA HIM compliant server shall be able to read a HIM configuration file and from that access the forest of trees it defines.\nA HIM compliant tree must follow the HIM rule set. The project specifying this tree must also define the domain metadata for this tree, and it may provide a public URL to a file containing the complete tree, possible also multiple public URLs to renditions of the tree in different formats such as YAML, JSON, etc.\nThe creation of a HIM configuration file is the responsibility of the HIM server implementor.\nConfiguration node types The following node types can be used in a configuration tree:\nBranch Taxonomy Proxy Configuration Tree Example This example shows a forest consisting of three local trees, and a remote tree:\nA local tree containing passenger car related signals, having the root node name VehicleData. A local tree containing passenger car related services, having the root node name VehicleServices. A local tree containing type passenger car related ype definitions, having the root node name Types. A remote tree containing charge station related signals, having the root node name ChargingStationData. HIM: type: branch description: Contains the set of trees that are managed as one virtual domain. VehicleData: type: taxonomy domain: Vehicle.Car.ResourceData version: X.Y.Z local: file://\u0026lt;full-path-name\u0026gt; public: https://himrepo.oem.com?taxonomy=Vehicle.Car.ResourceData.X.Y.Z description: …. VehicleServices: type: taxonomy domain: Vehicle.Car.ServiceData version: X.Y.Z local: file://\u0026lt;full-path-name\u0026gt; public: https://himrepo.oem.com?taxonomy=Vehicle.Car.ServiceData.X.Y.Z description: …. Types: type: taxonomy domain: Vehicle.Car.TypeDefinition version: X.Y.Z local: file://\u0026lt;full-path-name\u0026gt; public: https://himrepo.oem.com?taxonomy=Vehicle.Car.DataType.X.Y.Z description: …. ChargingStationData: type: proxy domain:ChargingStation.Vehicle.ResourceData version: X.Y.Z public: https://himrepo.energyco.com?taxonomy=ChargingStation.Vehicle.ResourceData.X.Y.Z description: …. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/type_definition_rule_set/basics/",
	"title": "Type Definition Model",
	"tags": [],
	"description": "",
	"content": "A type_definition tree contains data type definitions that are not part of the primitive datatypes defined by HIM.\nThe currently supported node types are suited for definition of structs.\nNode Types The node types for representing type definitions are:\nBranch Struct Property Please see more information about these node types here.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/data_entry/",
	"title": "Data Entry",
	"tags": [],
	"description": "",
	"content": "Data Entry It is the leaf nodes of a tree that represents and defines the actual data. The definition is expressed by metadata describing the data associated to the node.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/instances/",
	"title": "Instances",
	"tags": [],
	"description": "",
	"content": "It is not uncommon that when defining HIM taxonomies there is a need to repeat branches and data entries when multiple instances of the same object occurs. One mechanism to handle that is the include directive, but that does not solve how to compactly describe a branch structure that uniquely enumerates multiple includes. To avoid hard-coded repetitions of branches and data entries in the specification an instance-concept is supported. Instances remove the need of repeating definitions, by defining at the node itself how often it occurs in the resulting tree. They are meant as a short-cut in the specification and can interpreted by tools that expands it to a full size tree.\nDefinition How can I create instances for my branch? An instance can be defined in any branch node. The instantiation is done for every node in the subtree of this branch node. Instances are defined with the key-word instances, followed by its definition, which can be either: a list of strings, where each element defines a single instance, e.g. ['Left','Right'] results into two instances of every following data entry in the path, named Left and Right a string, followed by a range defined through [n,m], with n,m as integer and n \u0026lt;= m, which defines the number of instances. Position[1,4] results into 4 instances of every following data entry in the path, named Position1, Position2, Position3 and Position4. It is in HIM recommended to use 1 as start index for the first instance. If multiple instances occur in one node or on the path to a data entry, the instances get combined, by the order of occurrence. Following the example above, four position instances will be created for each of the \u0026lsquo;Left\u0026rsquo; and \u0026lsquo;Right\u0026rsquo; instances, resulting into a total number of 8 instances of the subtree. How can I exclude child-nodes from instantiation? Often it makes sense to instantiate all child-nodes of a branch. But there are cases, when nodes are linked more to the general concept of a subtree, but not to every the single instance of it. With examples from the VSS taxonomy, this could be the DoorCount, which would rather be Door.Count, WheelDiameter, which is rather linked to an axle rather than the wheel itself or Brake.FluidLevel which is not measured for a single break, but rather a system indication.\nTo exclude a child-node from the instantiation of the direct parent node, set the keyword instantiate to false (true by default). Please check the following example for details.\nExample Example from the VSS taxonomy:\n# Cabin.vspec Door: type: branch instances: - Row[1,4] - [\u0026#34;Left\u0026#34;,\u0026#34;Right\u0026#34;] description: All doors, including windows and switches #include SingleDoor.vspec Door Door.Count: datatype: uint8 type: attribute default: 4 instantiate: false description: Number of doors in vehicle. # SingleDoor.vspec # # Definition of a single door # IsOpen: datatype: boolean type: actuator description: Is door open or closed Results in the following dot-notated output:\nVehicle.Cabin.Door Vehicle.Cabin.Door.Count Vehicle.Cabin.Door.Row1 Vehicle.Cabin.Door.Row1.Left Vehicle.Cabin.Door.Row1.Left.IsOpen Vehicle.Cabin.Door.Row1.Right Vehicle.Cabin.Door.Row1.Right.IsOpen Vehicle.Cabin.Door.Row2 Vehicle.Cabin.Door.Row2.Left Vehicle.Cabin.Door.Row2.Left.IsOpen Vehicle.Cabin.Door.Row2.Right Vehicle.Cabin.Door.Row2.Right.IsOpen Vehicle.Cabin.Door.Row3 Vehicle.Cabin.Door.Row3.Left Vehicle.Cabin.Door.Row3.Left.IsOpen Vehicle.Cabin.Door.Row3.Right Vehicle.Cabin.Door.Row3.Right.IsOpen Vehicle.Cabin.Door.Row4 Vehicle.Cabin.Door.Row4.Left Vehicle.Cabin.Door.Row4.Left.IsOpen Vehicle.Cabin.Door.Row4.Right Vehicle.Cabin.Door.Row4.Right.IsOpen Redefinition The default instantiation provided by a standard HIM tree can be redefined with different instantiation information. If multiple definitions of a branch exist with different instance definitions, then the last found definition will be used. As an example, if only two rows of doors are needed, then a default HIM instance definition of four can be overridden by redefining the Door branch as shown in the example below.\n#Redefinition changing number of rows from 4 to 2 #The redefinition must appear \u0026#34;after\u0026#34; the original definition Vehicle.Cabin.Door: type: branch instances: - Row[1,2] - [\u0026#34;Left\u0026#34;,\u0026#34;Right\u0026#34;] description: All doors, including windows and switches Recommendations The HIM design shall support configurability of multiple variants of a \u0026ldquo;standard\u0026rdquo; taxonomy. This means that the default instantiation of a HIM taxonomy may not fit all needs of it. The following is an example from the VSS taxonomy where parts of the windshield signals defined in Body.vspec are shown below. VSS offers the possibility to control windshield heating separately for front and rear windshield, and VSS also gives the possibility to report washer fluid level separately for each windshield. This fits very well for a vehicle that has separate washer fluid containers for front and rear windshield and that offers heating for both windshields. But that is not the case for all vehicles, it is not even certain that all vehicles have two windshields. This sections gives recommendations on how to use VSS for a vehicle if the VSS specification does not offer an exact match of the capabilities of the vehicle.\nWindshield: type: branch instances: [\u0026#34;Front\u0026#34;, \u0026#34;Rear\u0026#34;] description: Windshield signals Windshield.Heating: type: branch description: Windshield heater signals Windshield.Heating.Status: datatype: boolean type: actuator description: Windshield heater status. 0 - off, 1 - on Windshield.WasherFluid: type: branch description: Windshield washer fluid signals Windshield.WasherFluid.LevelLow: datatype: boolean type: sensor description: Low level indication for washer fluid. True = Level Low. False = Level OK. Recommendation: Instance Mismatch If a vehicle does not have as many instances as specified in VSS then one of the following methods are recommended:\nRedefine the branch. If a vehicle for example does not have a rear windshield then append a redefinition at the end of the VSS: Vehicle.Body.Windshield: type: branch instances: [\u0026#34;Front\u0026#34;] description: Windshield signals Accept that a branch Vehicle.Body.Windshield.Rear will exist in the generated VSS representation, use mechanisms outside of VSS to ignore that branch Recommendation: Features shared among instances If a feature is shared among instances, it is recommended to publish that feature for all concerned instances.\nExample: In VSS washer fluid can be handled separately for front and rear windshield. If a vehicle use a common container serving both front and rear windshield, then it is recommended that the vehicle report information on that container in both Vehicle.Body.Windshield.Front.WasherFluid.LevelLow and Vehicle.Body.Windshield.Rear.WasherFluid.LevelLow.\nRecommendation: Features lacking for some instances Not all instances in a vehicle might have the same features. If e.g. the front windshield from the example above lack a heater, then it is recommended to use mechanisms outside of VSS to ignore Vehicle.Body.Windshield.Front.Heating.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/includes/",
	"title": "Includes",
	"tags": [],
	"description": "",
	"content": "An include directive in a HIM file will read the file it refers to and the contents of that file will be inserted into the current buffer in place of the include directive. The included file will, in its turn, be scanned for include directives to be replaced, effectively allowing formation of a tree of includedfiles.\nSee the figurefor an example of such a tree.\nFigure: Include directives\nThe include directive has the following format:\n#include \u0026lt;filename\u0026gt; [prefix] The \u0026lt;filename\u0026gt; part specifies the path, relative to the file with the #include directive, to the vspec file to replace the directive with.\nThe optional [prefix] specifies a branch name to be prepended to all signal entries in the included file. This allows a him file to be reused multiple times by different files, each file specifying their own branch to attach the included file to.\nAn example of an include directive is:\n#include doors.him chassis.doors The doors.him section specifies the file to include.\nThe chassis.doors section specifies that all signal entries in doors.him should have their names prefixed with chassis.doors.\nIf an included him file has node specifications that have already been defined prior to the included file, the new specifications in the included file will override the previous specifications.\nComplete subtrees can be reused by including them multiple times to different branches.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/data_entry/datatypes/",
	"title": "Datatypes",
	"tags": [],
	"description": "",
	"content": "HIM supports the datatype concepts:\nprimitive datatypes, composite datatypes, arrays. This chapter also mentions the related concepts of Timestamps, and Data streams.\nPrimitive datatypes The list below shows the primitive datatypes that are supported.\nName Description Min Max uint8 unsigned 8-bit integer 0 255 int8 signed 8-bit integer -128 127 uint16 unsigned 16-bit integer 0 65535 int16 signed 16-bit integer -32768 32767 uint32 unsigned 32-bit integer 0 4294967295 int32 signed 32-bit integer -2147483648 2147483647 uint64 unsigned 64-bit integer 0 2^64 - 1 int64 signed 64-bit integer -2^63 2^63 - 1 boolean boolean value 0/false 1/true float floating point number -3.4e -38 3.4e 38 double double precision floating point number -1.7e -300 1.7e 300 string character string n/a n/a Composite datatypes HIM also supports the \u0026lsquo;struct\u0026rsquo; composite datatype that groups a list of data variables into one object. The data variables in the list may of be primitive or composite type.\nThe recommended usage of structs is to have a separate tree with the information type \u0026lsquo;TypeDefinition\u0026rsquo; in which the struct is defined. The node that want to declare this struct as datatype then use the path to a node of type struct (node z in the example below) in the TypeDefinition tree as reference.\ndatatype: TypeDefinition.x.y.z This pattern enables efficient reuse of the struct definition by multiple nodes.\nHIM struct support is further described in the Structs chapter.\nArrays The primitive and composite datatypes above all define singleton data elements, but these can all be extended to define a sequence of elements of the same datatype, an array.\nBy default the size of the array is undefined, but by use of the optional metadata arraysize: x the size of the array can be specified (x elements in this case).\nThe syntax to declare an array is to concatenate the datatype with a pair of square brackets, as shown in the example from the VSS taxonomy by the data Vehicle.OBD.DTCList which contains a list of Diagnostic Trouble Code (DTC) string elements.\nDTCList: datatype: string[] type: sensor description: List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ) Timestamps Timestamps are in HIM typically represented as strings, formatted according to ISO 8601. Timestamps shall be expressed in UTC (Coordinated Universal Time), with special UTC designator (\u0026ldquo;Z\u0026rdquo;). Time resolution SHALL at least be seconds, with subsecond resolution as an optional degree of precision when desired. The time and date format shall be as shown below, where the sub-second data and delimiter is optional.\nYYYY-MM-DDTHH:MM:SS.ssssssZ Data Streams Data Entries, which describe resources offering binary streams (e.g. cameras), are not supported directly by HIM with a dedicated data type. Instead, they are described through the meta data about the sensor itself and how to retrieve the corresponding data stream.\nA camera can be a good example of it. The Data Entry for the camera and the corresponding video stream could look like:\nCamera: type: branch description: Information about the camera and how to connect to the video stream Camera.IsActive: type: actuator datatype: boolean description: If the camera is active, the client is able to retrieve the video stream Camera.URI: type: sensor datatype: string description: URI for retrieving the video stream, with information on how to access the stream (e.g. protocol, data format, encoding, etc.) In this example, it shows the usage of meta data about the status of the camera. The camera can be set to active through the same data entry (actuator). A dynamic data entry (sensor) is used for the URI of the video stream, which is expected to provide information on how to access the stream.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/data_entry/structs/",
	"title": "Structs Explained",
	"tags": [],
	"description": "",
	"content": "As mentioned in the chapter Composite datatypes a struct is defined using the node types \u0026lsquo;struct\u0026rsquo; and \u0026lsquo;property\u0026rsquo; in trees having the information type TypeDefinition, and it is referred to by using its path.\nThe struct node type can also be used in trees having the information type Service, which is described in HIM Services Rule Set.\nA struct definition in a Typedefinition tree can contain a member that has a different struct as its datatype. This other struct must then be defined elsewhere in the Typedefinition tree and referred to by its path.\nIntended usage The struct support in HIM is introduced to facilitate logical binding/grouping of data that originates from the same source. It is intended to be used only when it is important that the data is read or written in an atomic operation. It is not intended to be used to specify how data shall be packaged and serialized when transported.\nThe order of elements in a struct is from a HIM perspective considered as arbitrary. The HIM project will for this reason not publish guidelines on how to order items in the struct to minimize size, and no concept for introducing padding will exist.\nStructs shall be used in a HIM based catalog only when considered to give a significant advantage compared to using only primitive types.\nStructs vs. Aggregate HIM supports the keyword aggregate that can be used on branches to indicate that the branch preferably shall be read and written in atomic operations.\nThere have been criticism that aggregate changes the semantic meaning of branches and signals, i.e. that a data variable is no longer handed as an independent object. The exact meaning of aggregate is furthermore not well defined. Shall for example a write request (or update of sensor values) be rejected by an implementation if not all signals in the branch are updated in the same operation? Semantic interpretation is also ambiguous if the branch contains a mix of e.g. data objects with read-only and read-write permissions. Using structs as datatype is better aligned with the view that HIM data objects are independent objects regardless of whether they are of primitive or composite datatypes, and the semantic ambiguities related to aggregate are not present for structs.\nAggregate could however be useful as information on deployment level. It gives the possibility to indicate that in this particular deployment the signals in the branch shall be treated as an aggregate. Exact meaning of the aggregate keyword is then deployment specific. With this view, aggregate shall never be used in a standard HIM catalog, but can be added in a subsequent process for deployment-specific purposes.\nGeneral Idea and Basic Semantics A signal of struct type shall be defined in the same way as other VSS signals, the only difference would be that instead of using a primitive type there shall be a reference to a struct datatype. This means that structs can be used for all types of VSS signals (i.e. sensor, attribute and actuator). If a signal of struct type is sent or received, VSS expects all included items to have valid values, i.e. all items are mandatory. For example, if a struct contains the items A, B and C - then it is expected that the sent signal contains value for all items. If some items are considered optional then the value range of the items must be adapted to include values indicating \u0026ldquo;not available\u0026rdquo; or \u0026ldquo;undefined\u0026rdquo;, or additional items needs to be added to indicate which items that have valid values.\nHIM makes no assumption on how structs are transferred or stored by implementations. It is however expected that they are read and written by atomic operations. This means that the data storage shall be \u0026ldquo;locked\u0026rdquo; while the items of the struct are read, preventing changes to happen while reading/writing the items.\nStructs shall be defined in a separate tree. This means that signal definitions and types cannot exist in the same files. IS THE ABOVE CORRECT? STRUCTS CANNOT ALTERNATVELY BE DEFINED AS A CHILD SUBTREE?\nNaming Restrictions The HIM syntax shall not enforce any restrictions on naming for the datatype definition tree. It may even use the same branch structure as the data tree. This means that it theoretically at the same time could exist both a data object A.B.C and a struct definition A.B.C. This is not a problem as it always from context is clear whether a name refers to a data object or a datatype definition.\nSimple Definition and Usage This could be a hypothetical content of a HIM datatype definition file\nType: type: branch description: Root node for the datatype definition tree Type.DeliveryInfo: type: struct description: A struct type containing info for each delivery Type.DeliveryInfo.Address: datatype: string type: property description: Destination address Type.DeliveryInfo.Receiver: datatype: string type: property description: Name of receiver This struct definition could then be referenced from a HIM data tree.\nDelivery: datatype: Type.DeliveryInfo type: sensor The datatype definition file may contain sub-branches and #include-statements just like regular HIM files.\nType: type: branch description: Root node for the datatype definition tree Type.Powertrain: type: branch description: Powertrain types. #include Powertrain/Powertrain.him Types.Powertrain Name resolution Two ways of referring to a type are considered correct:\nIn Datatype Definition Tree:\nReference by absolute path Reference by (leaf) name to a struct definition within the same branch In Signal Tree:\nReference by absolute path Relative paths (e.g. ../Powertrain.SomeStruct) are not allowed. Structs in parent branches will not be visible, in those cases absolute path needs to be used instead.\nThe reference by leaf name is applicable only for structs referencing other structs!\nArray Support It is allowed to use a struct datatype in an array.\nDeliveryList: datatype: Types.DeliveryInfo[] type: sensor description: List of deliveries By default the array has an arbitrary number of element and may be empty. If a fixed size array is wanted the keyword arraysize can be used to specify size:\nDeliveryList: datatype: Types.DeliveryInfo[] arraysize: 5 type: sensor description: List of deliveries Structure in Structure It is allowed to refer to a structure type from within a structure as shown in the example below.\nType: type: branch description: Root node for the datatype definition tree Type.OpenHours: type: struct description: A struct type containing information on open hours Type.OpenHours.Open: datatype: uint8 type: property max: 24 description: Time the address opens Type.OpenHours.Close: datatype: uint8 type: property max: 24 description: Time the address close Type.DeliveryInfo: type: struct description: A struct type containing info for each delivery Type.DeliveryInfo.Address: datatype: string type: property description: Destination address Type.DeliveryInfo.Receiver: datatype: string type: property description: Name of receiver Type.DeliveryInfo.Open: datatype: Type.OpenHours type: property description: When is receiver available Order of declaration/definition The order of declaration/definition shall not matter. As signals and types are defined in different trees this is a topic only for struct definitions referring to other struct definitions. A hypothetical example is shown below. An item in the struct DeliveryInfo can refer to the struct OpenHours even if that struct is defined further down in the same file. If using -vt \u0026lt; file\u0026gt; multiple times all files except the first will be treated similar to overlays. This means that is allowed to define A.B.C in multiple files, but then subsequent (re-)definitions will overwrite what has been defined previously.\nDeliveryInfo: type: struct description: A struct type containing info for each delivery ... DeliveryInfo.Open: datatype: OpenHours type: property description: When is receiver available OpenHours: type: struct description: A struct type containing information on open hours ... Inline Struct The node type \u0026lsquo;struct\u0026rsquo; must only be used in trees of the information types \u0026lsquo;Typedefinition\u0026rsquo; and \u0026lsquo;Service\u0026rsquo;. Trees of any other information type that contains nodes having a datatype that is a struct must refer to the struct definition in a \u0026lsquo;Typedefinition\u0026rsquo; tree by use of the path to that struct.\nDefault Values Members of a struct may have a default value defined.\nAllowed Values A member of a struct may use the metadata allowed to restrict its allowed values (if allowed is supported for the used datatype).\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/",
	"title": "HIM Common Rule Set",
	"tags": [],
	"description": "",
	"content": "HIM Common Rule Set Rules that are used by multiple rule sets are described in this part of the document.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/resource_data_rule_set/",
	"title": "HIM Resource Data Rule Set",
	"tags": [],
	"description": "",
	"content": "HIM Resource Data Rule Set The rules that are specific for the information type resource_data is described in this part of the document, and together with the rules in the Common rule set part it forms the overall rules for this information type.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/service_data_rule_set/",
	"title": "HIM Service Data Rule Set",
	"tags": [],
	"description": "",
	"content": "HIM Service Data Rule Set The rules that are specific for the information type servicedata is described in this part of the document, and together with the rules in the Common rule set part it forms the overall rules for this information type.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/node_types/",
	"title": "Common Node types",
	"tags": [],
	"description": "",
	"content": "Common Node Types Node types that are used by more than one information type.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/type_definition_rule_set/",
	"title": "HIM Type Definition Rule Set",
	"tags": [],
	"description": "",
	"content": "HIM Type Definition Rule Set The rules that are specific for the information type type_definition is described in this part of the document, and together with the rules in the Common rule set part it forms the overall rules for this information type.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/data_entry/units/",
	"title": "Units",
	"tags": [],
	"description": "",
	"content": "Introduction to Units HIM keeps a list of the units of measurements that can be used as the value of the unit metadata, see the example below.\nVehicle.Speed: datatype: float type: sensor unit: km/h description: Vehicle speed. Data that has an associated unit from the list shall declare it using the unit metadata. It is allowed for a domain to specify an additional list with domain specific units that complement the common units list. Units shall if possible be based on SI-units, but exceptions like the speed example above are acceptable. The list contains entries of a unit with a prefix, e. g. mm for millimeter, which are the only prefixes that are valid. The unit must be written exactly as shown in the list.\nIn some cases it is natural to omit the data unit type. This concerns typically signals where data type string is used, but also signals where the value just represents a number, like in the example below:\nVehicle.Cabin.DoorCount: datatype: uint8 type: attribute default: 4 description: Number of doors in vehicle. HIM also supports percent and ratio as data units.\nList of supported Units This list is mainly derived from the International System of Units (SI).\nUnit Domain Description mm Distance Distance measured in millimeters cm Distance Distance measured in centimeters m Distance Distance measured in meters km Distance Distance measured in kilometers inch Distance Distance measured in inches km/h Speed Speed measured in kilometers per hours m/s Speed Speed measured in meters per second m/s^2 Acceleration Acceleration measured in meters per second squared cm/s^2 Acceleration Acceleration measured in centimeters per second squared ml Volume Volume measured in milliliters l Volume Volume measured in liters cm^3 Volume Volume measured in cubic centimeters celsius Temperature Temperature measured in degree celsius degrees Angle Angle measured in degrees degrees/s Angular Speed Angular speed measured in degrees per second W Power Power measured in watts kW Power Power measured in kilowatts PS Power Power measured in horsepower kWh Energy Consumption Energy consumption measured in kilowatt hours g Weight Mass measured in grams kg Weight Mass measured in kilograms lbs Weight Mass measured in pounds V Electric Potential Electric potential measured in volts A Electric Current Electric current measured in amperes Ah Electric Charge Electric charge measured in ampere hours ms Time Time measured in milliseconds s Time Time measured in seconds min Time Time measured in minutes h Time Time measured in hours day Time Time measured in days weeks Time Time measured in weeks months Time Time measured in months years Time Time measured in years UNIX Timestamp Time Unix time is a system for describing a point in time. It is the number of seconds that have elapsed since the Unix epoch, excluding leap seconds. mbar Pressure Pressure measured in millibars Pa Pressure Pressure measured in pascal kPa Pressure Pressure measured in kilopascal stars Rating Rating measured in stars g/s Mass per time Mass per time measured in grams per second g/km Mass per distance Mass per distance measured in grams per kilometers kWh/100km Energy Consumption per distance Energy consumption per distance measured in kilowatt hours per 100 kilometers ml/100km Volume per distance Volume per distance measured in milliliters per 100 kilometers l/100km Volume per distance Volume per distance measured in liters per 100 kilometers l/h Flow Flow measured in liters per hour mpg Distance per Volume Distance per volume measured in miles per gallon N Force Force measured in newton Nm Torque Torque measured in newton meters rpm Rotational Speed Rotational speed measured in revolutions per minute Hz Frequency Frequency measured in hertz ratio Relation Relation measured as ratio percent Relation Relation measured in percent \u0026hellip; \u0026hellip; \u0026hellip; "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/configuration_rule_set/node_types/",
	"title": "Configuration File Node types",
	"tags": [],
	"description": "",
	"content": "Configuration File Node Types Node types that may be used in a HIM configuration file, besides the branch type.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/configuration_rule_set/",
	"title": "HIM Configuration Rule Set",
	"tags": [],
	"description": "",
	"content": "HIM Configuration Rule Set The overall rule set for the information type configuration is described in this part of the document, together with the rules in the Common rule set part.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/resource_data_rule_set/actuator/",
	"title": "Actuator node",
	"tags": [],
	"description": "",
	"content": "Actuators are used to control the desired value of a property. Some properties in a vehicle cannot change instantly. A typical example is position of a seat or a window. Reading a value of an actuator shall return the current actual value, e.g. the current position of the seat, rather than the wanted/desired position. A typical example could be if someone wants to change the position of a seat from 0 to 100. This can be changed by setting the corresponding actuator to 100. If the actuator is read directly after the set request it will still return 0 as it might take some seconds before the seat reaches the wanted position of 100. If the seat by some reason is blocked or cannot be moved due to safety reasons it might never reach the wanted position. It is up to the vehicle to decide how long time it shall try to reach the desired value and what to do if it needs to give up.\nNodes of the type actuator must have the following mandatory metadata:\nName Type Datatype Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nUnit Min Max Allowed Comment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type branch as parent, and must not have any children.\nAn example of the specification of a actuator node is given below.\nTripMeterReading: datatype: float type: actuator unit: km description: Trip meter reading. comment: The trip meter is an odometer that can be manually reset by the driver "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/node_types/branch/",
	"title": "Branch node",
	"tags": [],
	"description": "",
	"content": "The interior of a HIM tree is built up of nodes that have the node type branch.\nNodes of the type branch must have the following mandatory metadata:\nName Type Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nComment Instances Aggregate For more information, please see the Common Rule Set: Optional Metadata.\nThe root node of a HIM tre must be of the node type branch.\nA leaf node cannot have the branch node type.\nIf it has a parent, then it must be of the node type branch.\nAn example of the specification of a branch node is given below.\nNodeName: type: branch description: This is a branch node containing its mandatory metadata. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/service_data_rule_set/iostruct/",
	"title": "IO-struct node",
	"tags": [],
	"description": "",
	"content": "An iostruct node type may be used to encapsulate multiple data points that have the relationship that they are all representing either Input parameters or Output parameters of the microservice that they are linked to.\nThis node type is only allowed in trees of the information type servicedata. For more information, please see respective parts of this document.\nAn iostruct node must have one of the two names Input or Output.\nNodes of the type iostruct must have the following mandatory metadata:\nName Type Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nComment For more information, please see the Common Rule Set: Optional Metadata.\nA leaf node cannot have the iostruct node type. A parent must be of the node type procedure. Children must be of the node types property or symlink. It must have at least one child. An example of the specification of a struct node is given below.\nInput: type: iostruct description: This is an iostruct node representing Input parameters of a microservice. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/service_data_rule_set/property/",
	"title": "Property node",
	"tags": [],
	"description": "",
	"content": "Data represented by the node type property have a relationship to any other data having the same iostruct parent in that they are all sampled in an \u0026ldquo;atomic\u0026rdquo; operation, i.e. the set of data points have the same timestamp representing the sample time.\nNodes of the type property must have the following mandatory metadata:\nName Type Datatype Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nUnit Min Max Allowed Comment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type iostruct as parent, and must not have any children.\nAn example of the specification of a property node is given below.\nType.OpenHours.Open: datatype: uint8 type: property max: 24 description: Time the address opens "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/type_definition_rule_set/property/",
	"title": "Property node",
	"tags": [],
	"description": "",
	"content": "Data represented by the node type property have a relationship to any other data having the same struct parent in that they are all sampled in an \u0026ldquo;atomic\u0026rdquo; operation, i.e. the set of data points have the same timestamp representing the sample time.\nNodes of the type property must have the following mandatory metadata:\nName Type Datatype Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nUnit Min Max Allowed Comment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type struct as parent, and must not have any children.\nAn example of the specification of a property node is given below.\nType.OpenHours.Open: datatype: uint8 type: property max: 24 description: Time the address opens "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/resource_data_rule_set/sensor/",
	"title": "Sensor node",
	"tags": [],
	"description": "",
	"content": "Sensors are signals to read values of properties in a vehicle. Values of sensors typically change over time. Reading a sensor shall return the current actual value of the related property, e.g. the current speed or the current position of the seat.\nNodes of the type sensor must have the following mandatory metadata:\nName Type Datatype Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nUnit Min Max Allowed Comment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type branch as parent, and must not have any children.\nAn example of the specification of a sensor node is given below.\nSpeed: type: sensor description: The vehicle speed. comment: For engine speed see Vehicle.Powertrain.CombustionEngine.Engine.Speed. datatype: float unit: km/h min: 0 max: 300 "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/type_definition_rule_set/struct/",
	"title": "Struct node",
	"tags": [],
	"description": "",
	"content": "A struct node type may be used to represent multiple data points that have the relationship that they are always sampled in an \u0026ldquo;atomic\u0026rdquo; operation, i. e. the set of samples have the same timestamp. An example of such a set of data points are the GPS dta points latitude, longitude, height.\nThis node type is only allowed in trees of the information types typedefinition or service. For more information, please see respective parts of this document.\nNodes of the type struct must have the following mandatory metadata:\nName Type Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nComment For more information, please see the Common Rule Set: Optional Metadata.\nA leaf node cannot have the struct node type. A parent must be of the node type branch or service. Children must be of the node type property. It must have at least one child. An example of the specification of a struct node is given below.\nNodeName: type: struct description: This is a struct node containing its mandatory metadata. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/service_data_rule_set/procedure/",
	"title": "procedure node",
	"tags": [],
	"description": "",
	"content": "The procedure node type must have the following mandatory metadata:\nName Type Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nComment For more information, please see the Common Rule Set: Optional Metadata.\nA parent must be of the node type branch. Children, if any, must be of the node type iostruct. An example of the specification of a procedure node is given below.\nmicroserviceName: type: procedure description: This is an example of a microservice procedure node containing its mandatory metadata. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/node_types/property/",
	"title": "Property node",
	"tags": [],
	"description": "",
	"content": "The property node type is used in both the service and typedefinition rule sets, but as they differ slightly on the semantics in respective rule set it has a separate definition in each of the rule sets, please see their definitions in the Service Rule Set:Property node node type and the Type Definition Rule Set:Property node node type respectively.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/configuration_rule_set/node_types/proxy/",
	"title": "Proxy node",
	"tags": [],
	"description": "",
	"content": "A proxy node in a HIM configuration file defines a tree that the server managing this forest does not have a local copy of. It however knows how to forward requests to the server that managaes the tree and has a local copy of it. An example could be a home automation scenario, where a server deployed in a car knows the Local Area Network access point address bearer type, so that when in proximity of the LAN, and after the vehicle has connected to it, requests received by the HIM server in he vehicle can then be routed to the server deployed on the LAN.\nNodes of the type proxy must have the following mandatory metadata:\nName Type Domain Version Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nPublic Comment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type branch as parent, and must not have any children.\nName The name of this node must be the same as that of the root node of the tree it is representing, and it must be unique in the forest described in this file. This makes it possible to change the root node name of a \u0026ldquo;standard\u0026rdquo; tree, which then enables that multiple instances of the same standard tree can be present in the same forest. A scenario where this may happen is when a truck has more than one trailer that each is represented by the same standard tree. The trailers can then be distinguished by having different root node names.\nDomain The domain metadata is what defines the domain and information type that the tree represents. A domain name dot delimited segment names:\nThe first segment (the left-most) represents a \u0026ldquo;top domain\u0026rdquo;. Examples of top domains can be Automotive, RoadInfrastructure, Aviation. Following segments, except the last, are sub domains. Examples of sub domains can be Car, Truck, Trailer, ChargingStation. The number of sub domains is not fixed, but it is recomended to stay below five. Each additional sub domain should be a subset of the previos domain. The last segment (the right-most) represents the information type. Version The version shall be identical to the version of the tree where it shall be mandatory. Versioning shall be based on the Semantic versioning principles.\nPublic The public metadata shall, if available, be a URL to a public copy of the tree. It may be used to provision a server with a copy of the tree, but also by a client to obtain a copy instead of e. g. requesting the proxy server to provision a copy from the server managing it.\nAn example of the specification of a taxonomy node is given below.\nVehicleData: type: proxy domain: HomeAutomation.Zigbee.ResourceData version: X.Y.Z public: https://himrepo.oem.com?taxonomy=HomeAutomation.Zigbee.ResourceData.X.Y.Z description: …. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/service_data_rule_set/symlink/",
	"title": "Symlink node",
	"tags": [],
	"description": "",
	"content": "Data represented by the node type symlink have a relationship to any other data having the same iostruct parent in that they are all representing either Input parameters or Output parameters of the service that they are linked to.\nAn Otput parameter declared as a symlink will lead to that the returned value is read from that data point.\nAn Input parameter declared as a symlink will lead to that the provided input value is written to that data point.\nNodes of the type symlink must have the following mandatory metadata:\nName Type Path Domain Version Description The Path must be a valid path to a leaf node in the tree declared by the Domain and Version metadata.\nThe Domain must declare an existing HIM tree of information type resourcedata.\nThe Version must be a dot delimited triplet declaring a version of the tree eclared by the Domain. The triplet may a suffix of either \u0026ldquo;+\u0026rdquo; or \u0026ldquo;-\u0026rdquo;, denoting that also any following or previous versions are also valid.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nComment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type iostruct as parent, and must not have any children.\nAn example of the specification of a symlink node is given below.\nVehicleService.GPS.GetPosition.Output.Latitude: type: symlink path: Vehicle.CurrentLocation.Latitude domain: Automotive.Vehicle.Car.ResourceData version: 3.0.0+ description: This is a symlink to a VSS tree. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/configuration_rule_set/node_types/taxonomy/",
	"title": "Taxonomy node",
	"tags": [],
	"description": "",
	"content": "A taxonomy node in a HIM configuration file defines a tree that the server managing this forest have a local and complete copy of. This means that the server can efficiently parse the tree to e. g. verify that a client request for information points to an existing node in the tree.\nNodes of the type taxonomy must have the following mandatory metadata:\nName Type Domain Version Local Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nPublic Comment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type branch as parent, and must not have any children.\nName The name of this node must be the same as that of the root node of the tree it is representing, and it must be unique in the forest described in this file. This makes it possible to change the root node name of a \u0026ldquo;standard\u0026rdquo; tree, which then enables that multiple instances of the same standard tree can be present in the same forest. A scenario where this may happen is when a truck has more than one trailer that each is represented by the same standard tree. The trailers can then be distinguished by having different root node names.\nDomain The domain metadata is what defines the domain and information type that the tree represents. A domain name dot delimited segment names:\nThe first segment (the left-most) represents a \u0026ldquo;top domain\u0026rdquo;. Examples of top domains can be Automotive, RoadInfrastructure, Aviation. Following segments, except the last, are sub domains. Examples of sub domains can be Car, Truck, Trailer, ChargingStation. The number of sub domains is not fixed, but it is recomended to stay below five. Each additional sub domain should be a subset of the previos domain. The last segment (the right-most) represents the information type. Version The version shall be identical to the version of the tree where it shall be mandatory. Versioning shall be based on the Semantic versioning principles.\nLocal The local metadata shall be a file URL or similar that points to a local file that contains the tree. The local metadta shall not be supplied to a client requesting the configuration file.\nPublic The public metadata shall, if available, be a URL to a public copy of the tree. It may be used to provision a server with a copy of the tree, but also by a client to obtin a copy instead of e. g. requesting the server to provision a copy.\nAn example of the specification of a taxonomy node is given below.\nVehicleData: type: taxonomy domain: Vehicle.Car.ResourceData version: X.Y.Z local: file://\u0026lt;full-path-name\u0026gt; public: https://himrepo.oem.com?taxonomy=Vehicle.Car.ResourceData.X.Y.Z description: …. "
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/resource_data_rule_set/attribute/",
	"title": "Attribute node",
	"tags": [],
	"description": "",
	"content": "Nodes of the types attribute must have the following mandatory metadata:\nName Type Datatype Default Description For more information, see the Common Rule Set: Mandatory Metadata.\nBesides the mandatory metadata mentioned above, the following optional metadata may be used\nUnit Comment For more information, please see the Common Rule Set: Optional Metadata.\nThis node type must have a node of type branch as parent, and must not have any children.\nAn example of the specification of an attribute node is given below.\nMaxPower: datatype: uint16 type: attribute default: 0 unit: kW description: Peak power, in kilowatts, that the engine can generate. Default An attribute must define a default value, which is the persistent value assigned to the node. Although categorized as persistent, it may be updated, but it should typically not change more than once per ignition cycle.\nIt is possible to set default values also to array elements. In this case square brackets shall be used. The value for each element in the array must be specified. The size of the array is given by the number of elements specified within the square brackets.\nExample 1: Empty Array\ndefault: [] Example 2: Array with 3 elements, first element has value 1, second element value 2, third element value 0\ndefault: [1, 2, 0] Full example, array with two elements, first with value2, second with value 3:\nSeatPosCount: datatype: uint8[] type: attribute default: [2, 3] description: Number of seats across each row from the front to the rear Using default values for structs is not allowed!\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/common_rule_set/data_entry/value_restrictions/",
	"title": "Value Restrictions",
	"tags": [],
	"description": "",
	"content": "HIM supports the following metadata for restricting the valid values of data.\nmin max allowed Min The minimum value, within the interval of the given datatype, that the data entry can be assigned. If omitted, the minimum value will be the “Min” value for the given datatype. The min restrictions can only be used data having a \u0026ldquo;number\u0026quot;datatype (intx, uintx, float, double). Must not be specified if allowed is defined in the same node.\nMax The maximum value, within the interval of the given datatype, that the data entry can be assigned. If omitted, the maximum value will be the “Max” value for the given datatype. The max restrictions can only be used data having a \u0026ldquo;number\u0026quot;datatype (intx, uintx, float, double). Must not be specified if allowed is defined in the same node.\nMin and Max Example Powertrain.TractionBattery.StateOfCharge.Current: type: sensor unit: percent datatype: float min: 0 max: 100.0 description: Physical state of charge of the high voltage battery, relative to net capacity. Allowed The allowed restriction defines a array of accepted data values, defined as a comma separated list of values confined within square brackets, see example below. It is expected, that any value not mentioned in the array is considered an error and the implementation of the specification shall react accordingly. The datatype of the array elements shall be compatible with the datatype defined for the data entry itself.\nSteeringWheel.Position: datatype: string type: attribute default: \u0026#39;FRONT_LEFT\u0026#39; allowed: [\u0026#39;FRONT_LEFT\u0026#39;, \u0026#39;FRONT_RIGHT\u0026#39;] description: Position of the steering wheel on the left or right side of the vehicle. If allowed is set, min or max cannot be defined.\nallowed is valid for all datatypes.\nRecommendation on String values For string values used for allowed statements it is recommended to start with A-Z and then use only A-Z, 0-9 and underscore (_). It is recommended to use single quotes (') as delimiter before and after the string value. It is not recommended to specify a dedicated value corresponding to \u0026ldquo;unknown\u0026rdquo; or \u0026ldquo;undefined\u0026rdquo; as data values in general are not expected to have unique values for this.\nAllowed values for array types The allowed keyword can also be used for array datatypes. In that case, allowed specifies the only valid values for all the array elements, see example below.\nDogBreeds: datatype: string[] type: attribute allowed: [\u0026#39;AKITA\u0026#39;, \u0026#39;BOXER\u0026#39;, \u0026#39;DACHSHUND\u0026#39;, \u0026#39;PAPILLON\u0026#39;, \u0026#39;PUG\u0026#39;, \u0026#39;VIZSLA\u0026#39;] description: Brief list of dog breeds. Examples of valid arrays:\n[] # Empty array [\u0026#39;BOXER\u0026#39;] [\u0026#39;PAPILLON\u0026#39;, \u0026#39;VIZSLA\u0026#39;, \u0026#39;BOXER\u0026#39;, \u0026#39;AKITA\u0026#39;, \u0026#39;DACHSHUND\u0026#39;] [\u0026#39;PUG\u0026#39;, \u0026#39;PUG\u0026#39;] # duplication is allowed Example of an invalid array:\n[\u0026#39;PAPILLON\u0026#39;, \u0026#39;VIZSLA\u0026#39;, \u0026#39;LOBSTER\u0026#39;] # LOBSTER is not in the allowed value list Allowed for struct types Please see struct documentation.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/",
	"title": "Hierarchical Information Model",
	"tags": [],
	"description": "",
	"content": "Hierarchical Information Model The Hierarchical Information Model (HIM) is an initiative by COVESA to define a syntax for how to define taxonomies containing different types of information. The documentation, source code and releases can be found in the HIM github repository.\nThe information of a domain that is described using HIM is represented in a graph made up of a tree structure with parent-child relationships, as shown in Figure 1. *Figure 1. HIM graph structure\nThe model provides a structured solution to a scenario where an entity, e. g. a server, manages multiple domain taxonomies.\nA domain can in the HIM context be defined with the help of two dimensions:\na \u0026lsquo;coherent\u0026rsquo; dimension which represents information related to something that is logically coherent. Examples are a car, a truck, a trailer, an airplane, etc., an \u0026lsquo;information type\u0026rsquo; dimension that is used in the description of a coherent dimension using a specific information type. The currently defined information types are listed below. Resource data Service data Type definitions HIM specifies rule sets for the different information types that can then be used to define taxonomies for different coherent domains.\nThe creation of taxonomies for different domains is not done within the HIM project, it is expected to be done by other projects using the HIM rule sets. One example of such a project is the Vehicle Signal Specification project.\nThe documentation is structured in the different rule sets shortly described below.\nHIM Resource Data Rule Set Rules for describing resources that can be represented by static or dynamically changing data values.\nHIM Service Data Rule Set Rules for describing services that can be represented by procedure signatures.\nHIM Type Definition Rule Set Rules for describing complex datatype definitions, specifically struct definitions.\nHIM Configuration Rule Set Rules for how a set of domain taxonomies is defined.\nHIM Common Rule Set Rules that are commonly used in the other rule sets.\nHeritage The ideas behind HIM originated in the COVESA VSS project, when interest started to be raised for using it for of not only resource data but also service data, and for different domains than the legacy VSS passenger car domain. This may explain why examples in this documentation are often taken from that domain.\n"
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://covesa.github.io/hierarchical_information_model/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]